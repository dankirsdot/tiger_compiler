structure A = Absyn

%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | UMINUS
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE
  | LOWER_THAN_ELSE

%nonterm  exp of A.exp 
| program of A.exp
| decs of A.dec list
| dec of A.dec
| tydec of A.dec
| vardec of A.dec
| fundec of A.dec
| ty of A.ty
| tyfields of A.field list
| lvalue of A.var
| expseq of (A.exp * pos) list
| args of A.exp list
| recfields of (A.symbol * A.exp * pos) list

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE
        DO OF NIL

%prefer THEN ELSE LPAREN

%right OF
%nonassoc FUNCTION VAR TYPE THEN DO ASSIGN
%nonassoc LOWER_THAN_ELSE
%nonassoc ELSE
%left AND OR
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

program	: exp (exp)

decs :             ([])
     | dec decs    (dec :: decs)

dec : tydec  (tydec)
    | vardec (vardec)
    | fundec (fundec)

tydec : TYPE ID EQ ty (A.TypeDec[{name=Symbol.symbol(ID), ty=ty, pos=TYPEleft}])

ty : ID                      (A.NameTy(Symbol.symbol(ID), IDleft))
   | LBRACE tyfields RBRACE  (A.RecordTy(tyfields))
   | ARRAY OF ID             (A.ArrayTy(Symbol.symbol(ID), ARRAYleft))

tyfields :                            ([])
         | ID COLON ID                ({name=Symbol.symbol(ID1), escape=ref true, typ=Symbol.symbol(ID2), pos=ID1left} :: [])
         | ID COLON ID COMMA tyfields  ({name=Symbol.symbol(ID1), escape=ref true, typ=Symbol.symbol(ID2), pos=ID1left} :: tyfields)

vardec : VAR ID ASSIGN exp          (A.VarDec{name=Symbol.symbol(ID), escape=ref true, typ=NONE, init=exp, pos=VARleft})
       | VAR ID COLON ID ASSIGN exp  (A.VarDec{name=Symbol.symbol(ID1), escape=ref true, typ=SOME (Symbol.symbol(ID2), ID2left), init=exp, pos=VARleft})

fundec : FUNCTION ID LPAREN tyfields RPAREN EQ exp            (A.FunctionDec[{name=Symbol.symbol(ID), params=tyfields, result=NONE, body=exp, pos=FUNCTIONleft}])
       | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp (A.FunctionDec [{name=Symbol.symbol(ID1), params=tyfields, result=SOME (Symbol.symbol(ID2), ID2left), body=exp, pos=FUNCTIONleft}])

lvalue : ID  (A.SimpleVar(Symbol.symbol(ID), IDleft))
       | ID LBRACK exp RBRACK  (A.SubscriptVar(A.SimpleVar(Symbol.symbol(ID),IDleft), exp, IDleft))
       | lvalue LBRACK exp RBRACK  (A.SubscriptVar(lvalue, exp, lvalueleft))
       | lvalue DOT ID            (A.FieldVar(lvalue, Symbol.symbol(ID), lvalueleft))


exp : lvalue                                (A.VarExp(lvalue))
    | lvalue ASSIGN exp                     (A.AssignExp {var = lvalue, exp = exp, pos = lvalueleft}) 
    | NIL                                   (A.NilExp)
    | INT                                   (A.IntExp(INT))
    | STRING                                (A.StringExp(STRING, STRINGleft))
    | LPAREN expseq RPAREN                  (A.SeqExp(expseq))
    | MINUS exp %prec UMINUS                (A.OpExp{left=A.IntExp(0), oper=A.MinusOp, right=exp, pos=MINUSleft})
    | ID LPAREN args RPAREN                 (A.CallExp{func=Symbol.symbol(ID), args=args, pos=IDleft})
    | exp PLUS exp                          (A.OpExp{left=exp1, oper=A.PlusOp, right=exp2, pos=PLUSleft})
    | exp TIMES exp                         (A.OpExp{left=exp1, oper=A.TimesOp, right=exp2, pos=TIMESleft})
    | exp MINUS exp                         (A.OpExp{left=exp1, oper=A.MinusOp, right=exp2, pos=MINUSleft})
    | exp DIVIDE exp                        (A.OpExp{left=exp1, oper=A.DivideOp, right=exp2, pos=DIVIDEleft})
    | exp EQ exp                            (A.OpExp{left=exp1, oper=A.EqOp, right=exp2, pos=EQleft})
    | exp NEQ exp                           (A.OpExp{left=exp1, oper=A.NeqOp, right=exp2, pos=NEQleft})
    | exp LT exp                            (A.OpExp{left=exp1, oper=A.LtOp, right=exp2, pos=LTleft})
    | exp LE exp                            (A.OpExp{left=exp1, oper=A.LeOp, right=exp2, pos=LEleft})
    | exp GT exp                            (A.OpExp{left=exp1, oper=A.GtOp, right=exp2, pos=GTleft})
    | exp GE exp                            (A.OpExp{left=exp1, oper=A.GeOp, right=exp2, pos=GEleft})
    | exp AND exp                           (A.IfExp{test=exp1, then'=exp2, else'=SOME (A.IntExp(0)), pos=ANDleft})
    | exp OR exp                            (A.IfExp{test=exp1, then'=A.IntExp(1), else'=SOME exp2, pos=ORleft})
    | ID LBRACE recfields RBRACE            (A.RecordExp{fields=recfields, typ=Symbol.symbol(ID), pos=IDleft})
    | ID LBRACK exp RBRACK OF exp           (A.ArrayExp{typ=Symbol.symbol(ID), size=exp, init=exp, pos=IDleft})
    | IF exp THEN exp ELSE exp              (A.IfExp{test=exp1, then'=exp2, else'=SOME exp3, pos=IFleft})
    | IF exp THEN exp %prec LOWER_THAN_ELSE ( A.IfExp{test=exp1, then'=exp2, else'=NONE, pos=IFleft})
    | WHILE exp DO exp                      (A.WhileExp{test=exp1, body=exp2, pos=WHILEleft})
    | FOR ID ASSIGN exp TO exp DO exp       (A.ForExp{var=Symbol.symbol(ID), escape=ref true, lo=exp1, hi=exp2, body=exp3, pos=FORleft})
    | ID LPAREN args RPAREN              (A.CallExp{func=Symbol.symbol(ID), args=args, pos=IDleft})
    | BREAK                                 (A.BreakExp(BREAKleft))
    | LET decs IN expseq END                (A.LetExp{decs=decs, body=A.SeqExp(expseq), pos=LETleft})

expseq :                       ([])
       | exp                    ((exp, expleft) :: [])
       | exp SEMICOLON expseq   ((exp, expleft) :: expseq)

recfields :   (*tyafields*)                        ([])
          | ID EQ exp                 ( (Symbol.symbol(ID), exp, IDleft) :: [])
          | ID EQ exp COMMA recfields ((Symbol.symbol(ID), exp, IDleft) :: recfields)

args : (* funclist*)    ([])
     | exp            (exp :: [])
     | exp COMMA args (exp :: args)
